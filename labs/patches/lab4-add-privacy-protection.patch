diff --git a/apps/api/Dockerfile b/apps/api/Dockerfile
index 092b203..44c742e 100644
--- a/apps/api/Dockerfile
+++ b/apps/api/Dockerfile
@@ -11,7 +11,8 @@ RUN pip install --no-cache-dir "poetry==$POETRY_VERSION" \
 
 COPY pyproject.toml poetry.lock* ./
 RUN poetry lock --no-update \
-    && poetry install --no-root --no-ansi
+    && poetry install --with pii --no-root --no-ansi \
+    && python -m spacy download en_core_web_lg
 
 COPY apps/api ./apps/api
 
diff --git a/apps/api/routers/inference.py b/apps/api/routers/inference.py
index 954afbe..02024d4 100644
--- a/apps/api/routers/inference.py
+++ b/apps/api/routers/inference.py
@@ -6,6 +6,7 @@ from typing import Dict, List
 from fastapi import APIRouter, HTTPException, Request
 from apps.api.schemas.request import ChatRequest
 from apps.api.schemas.response import ChatResponse
+from apps.api.utils.pii_masker import PIIMasker
 
 logger = logging.getLogger(__name__)
 
@@ -39,8 +40,18 @@ async def chat(request: ChatRequest, app_request: Request):
             status_code=503,
             detail="LLM service unavailable. Please check your configuration."
         )
+    # Mask PII in user message before processing
     user_message = request.user_message
 
+    try:
+        pii_masking_enabled = True if settings is None else getattr(
+            settings, "pii_masking_enabled", True)
+        if pii_masking_enabled:
+            user_message = PIIMasker.get_instance().mask(user_message)
+    except Exception as e:
+        logger.warning(
+            f"PII masking failed, proceeding with original message: {e}")
+
     try:
         # Get or create session
         if request.session_id not in sessions:
diff --git a/apps/api/utils/pii_masker.py b/apps/api/utils/pii_masker.py
new file mode 100644
index 0000000..d2b6690
--- /dev/null
+++ b/apps/api/utils/pii_masker.py
@@ -0,0 +1,109 @@
+import threading
+from typing import Dict, Optional
+
+from presidio_analyzer import AnalyzerEngine, RecognizerResult
+from presidio_anonymizer import AnonymizerEngine
+from presidio_anonymizer.entities import OperatorConfig
+
+
+class PIIMasker:
+    """
+    Minimal Presidio wrapper to detect and mask PII in text.
+
+    Key Features:
+    - Detects various PII entities (SSN, credit cards, emails, phones, etc.)
+    - Uses context-aware filtering to reduce false positives
+    - Handles common abbreviations (US, UK, CA, etc.) intelligently
+    - Properly masks sensitive data with appropriate patterns
+
+    """
+
+    _instance: Optional["PIIMasker"] = None
+    _lock = threading.Lock()
+
+    def __init__(self, language: str = "en", score_threshold: float = 0.5,
+                 anonymizers: Optional[Dict[str, OperatorConfig]] = None):
+        self.analyzer = AnalyzerEngine()
+        self.anonymizer = AnonymizerEngine()
+        self.language = language
+        self.score_threshold = score_threshold
+
+        # Default anonymization policy: replace with entity placeholders
+        if anonymizers is None:
+            self.anonymizers = {
+                "DEFAULT": OperatorConfig("replace", {"new_value": "{{PII}}"}),
+                "PHONE_NUMBER": OperatorConfig("replace", {"new_value": "{{PHONE}}"}),
+                "CREDIT_CARD": OperatorConfig("mask", {"masking_char": "*", "chars_to_mask": 4, "from_end": True}),
+                "EMAIL_ADDRESS": OperatorConfig("replace", {"new_value": "{{EMAIL}}"}),
+                "PERSON": OperatorConfig("replace", {"new_value": "{{NAME}}"}),
+                "IP_ADDRESS": OperatorConfig("replace", {"new_value": "{{IP}}"}),
+                "IBAN_CODE": OperatorConfig("replace", {"new_value": "{{IBAN}}"}),
+                "US_SSN": OperatorConfig("mask", {"masking_char": "*", "chars_to_mask": 4, "from_end": True}),
+                "US_ITIN": OperatorConfig("mask", {"masking_char": "*", "chars_to_mask": 4, "from_end": True}),
+                "US_PASSPORT": OperatorConfig("mask", {"masking_char": "*", "chars_to_mask": 3, "from_end": True}),
+                "US_DRIVER_LICENSE": OperatorConfig("mask", {"masking_char": "*", "chars_to_mask": 4, "from_end": True}),
+                # Handle common false positives for location entities
+                # Keep location entities to avoid masking "US", "UK", etc.
+                "LOCATION": OperatorConfig("keep", {}),
+            }
+        else:
+            self.anonymizers = anonymizers
+
+    @classmethod
+    def get_instance(cls) -> "PIIMasker":
+        if cls._instance is None:
+            with cls._lock:
+                if cls._instance is None:
+                    cls._instance = PIIMasker()
+        return cls._instance
+
+    def mask(self, text: str) -> str:
+        if not text:
+            return text
+        try:
+            results: list[RecognizerResult] = self.analyzer.analyze(
+                text=text,
+                language=self.language,
+                score_threshold=self.score_threshold,
+            )
+        except Exception:
+            return text
+        if not results:
+            return text
+
+        # Filter out common false positives for LOCATION entities
+        # that are likely abbreviations in sensitive contexts
+        filtered_results = []
+        for r in results:
+            if r.entity_type == "LOCATION":
+                detected_text = text[r.start:r.end].upper()
+                # Common country/state abbreviations that are often false positives
+                # when appearing near sensitive data like SSN, credit cards, etc.
+                common_abbreviations = {"US", "UK", "CA",
+                                        "NY", "TX", "FL", "IL", "PA", "OH", "MI"}
+                if detected_text in common_abbreviations and r.score < 0.9:
+                    # Skip this entity if it's a common abbreviation with low confidence
+                    continue
+            filtered_results.append(r)
+
+        if not filtered_results:
+            return text
+
+        # Build per-entity config map, fallback to DEFAULT
+        operators: Dict[str, OperatorConfig] = {}
+        for r in filtered_results:
+            ent = r.entity_type
+            if ent in self.anonymizers:
+                operators[ent] = self.anonymizers[ent]
+            else:
+                operators[ent] = self.anonymizers.get("DEFAULT")
+
+        try:
+            out = self.anonymizer.anonymize(
+                text=text,
+                analyzer_results=filtered_results,
+                operators=operators,
+            )
+            return out.text
+        except Exception:
+            return text
diff --git a/pyproject.toml b/pyproject.toml
index 7c7462b..6869c4a 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -17,6 +17,13 @@ httpx = "^0.27.0"
 openlit = "^1.35"
 openai = ">=1.92.0"
 
+[tool.poetry.group.pii]
+optional = true
+
+[tool.poetry.group.pii.dependencies]
+presidio-analyzer = "^2.2.0"
+presidio-anonymizer = "^2.2.0"
+spacy = "^3.7.0"
 
 [tool.poetry.group.dev.dependencies]
 pytest = "^8.3.0"
